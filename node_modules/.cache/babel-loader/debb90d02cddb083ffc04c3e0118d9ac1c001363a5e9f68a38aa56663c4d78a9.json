{"ast":null,"code":"export default function (objects, bbox, n) {\n  var x0 = bbox[0],\n    y0 = bbox[1],\n    x1 = bbox[2],\n    y1 = bbox[3],\n    kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n    ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n  function quantizePoint(input) {\n    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n  }\n  function quantizePoints(input, m) {\n    var i = -1,\n      j = 0,\n      n = input.length,\n      output = new Array(n),\n      // pessimistic\n      pi,\n      px,\n      py,\n      x,\n      y;\n    while (++i < n) {\n      pi = input[i];\n      x = Math.round((pi[0] - x0) * kx);\n      y = Math.round((pi[1] - y0) * ky);\n      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n    }\n\n    output.length = j;\n    while (j < m) j = output.push([output[0][0], output[0][1]]);\n    return output;\n  }\n  function quantizeLine(input) {\n    return quantizePoints(input, 2);\n  }\n  function quantizeRing(input) {\n    return quantizePoints(input, 4);\n  }\n  function quantizePolygon(input) {\n    return input.map(quantizeRing);\n  }\n  function quantizeGeometry(o) {\n    if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n  }\n  var quantizeGeometryType = {\n    GeometryCollection: function (o) {\n      o.geometries.forEach(quantizeGeometry);\n    },\n    Point: function (o) {\n      o.coordinates = quantizePoint(o.coordinates);\n    },\n    MultiPoint: function (o) {\n      o.coordinates = o.coordinates.map(quantizePoint);\n    },\n    LineString: function (o) {\n      o.arcs = quantizeLine(o.arcs);\n    },\n    MultiLineString: function (o) {\n      o.arcs = o.arcs.map(quantizeLine);\n    },\n    Polygon: function (o) {\n      o.arcs = quantizePolygon(o.arcs);\n    },\n    MultiPolygon: function (o) {\n      o.arcs = o.arcs.map(quantizePolygon);\n    }\n  };\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n}","map":{"version":3,"names":["objects","bbox","n","x0","y0","x1","y1","kx","ky","quantizePoint","input","Math","round","quantizePoints","m","i","j","length","output","Array","pi","px","py","x","y","push","quantizeLine","quantizeRing","quantizePolygon","map","quantizeGeometry","o","quantizeGeometryType","hasOwnProperty","type","GeometryCollection","geometries","forEach","Point","coordinates","MultiPoint","LineString","arcs","MultiLineString","Polygon","MultiPolygon","key","scale","translate"],"sources":["C:/Users/johns/OneDrive/桌面/practice/map/node_modules/topojson-server/src/prequantize.js"],"sourcesContent":["export default function(objects, bbox, n) {\n  var x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3],\n      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n  function quantizePoint(input) {\n    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n  }\n\n  function quantizePoints(input, m) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n), // pessimistic\n        pi,\n        px,\n        py,\n        x,\n        y;\n\n    while (++i < n) {\n      pi = input[i];\n      x = Math.round((pi[0] - x0) * kx);\n      y = Math.round((pi[1] - y0) * ky);\n      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n    }\n\n    output.length = j;\n    while (j < m) j = output.push([output[0][0], output[0][1]]);\n    return output;\n  }\n\n  function quantizeLine(input) {\n    return quantizePoints(input, 2);\n  }\n\n  function quantizeRing(input) {\n    return quantizePoints(input, 4);\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizeRing);\n  }\n\n  function quantizeGeometry(o) {\n    if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n  }\n\n  var quantizeGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(quantizeGeometry); },\n    Point: function(o) { o.coordinates = quantizePoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates = o.coordinates.map(quantizePoint); },\n    LineString: function(o) { o.arcs = quantizeLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(quantizeLine); },\n    Polygon: function(o) { o.arcs = quantizePolygon(o.arcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(quantizePolygon); }\n  };\n\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}