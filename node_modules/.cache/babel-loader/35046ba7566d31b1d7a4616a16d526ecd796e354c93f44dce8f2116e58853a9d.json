{"ast":null,"code":"// https://github.com/topojson/topojson-client v3.1.0 Copyright 2019 Mike Bostock\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.topojson = global.topojson || {}));\n})(this, function (exports) {\n  'use strict';\n\n  function identity(x) {\n    return x;\n  }\n  function transform(transform) {\n    if (transform == null) return identity;\n    var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n    return function (input, i) {\n      if (!i) x0 = y0 = 0;\n      var j = 2,\n        n = input.length,\n        output = new Array(n);\n      output[0] = (x0 += input[0]) * kx + dx;\n      output[1] = (y0 += input[1]) * ky + dy;\n      while (j < n) output[j] = input[j], ++j;\n      return output;\n    };\n  }\n  function bbox(topology) {\n    var t = transform(topology.transform),\n      key,\n      x0 = Infinity,\n      y0 = x0,\n      x1 = -x0,\n      y1 = -x0;\n    function bboxPoint(p) {\n      p = t(p);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n    function bboxGeometry(o) {\n      switch (o.type) {\n        case \"GeometryCollection\":\n          o.geometries.forEach(bboxGeometry);\n          break;\n        case \"Point\":\n          bboxPoint(o.coordinates);\n          break;\n        case \"MultiPoint\":\n          o.coordinates.forEach(bboxPoint);\n          break;\n      }\n    }\n    topology.arcs.forEach(function (arc) {\n      var i = -1,\n        n = arc.length,\n        p;\n      while (++i < n) {\n        p = t(arc[i], i);\n        if (p[0] < x0) x0 = p[0];\n        if (p[0] > x1) x1 = p[0];\n        if (p[1] < y0) y0 = p[1];\n        if (p[1] > y1) y1 = p[1];\n      }\n    });\n    for (key in topology.objects) {\n      bboxGeometry(topology.objects[key]);\n    }\n    return [x0, y0, x1, y1];\n  }\n  function reverse(array, n) {\n    var t,\n      j = array.length,\n      i = j - n;\n    while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n  }\n  function feature(topology, o) {\n    if (typeof o === \"string\") o = topology.objects[o];\n    return o.type === \"GeometryCollection\" ? {\n      type: \"FeatureCollection\",\n      features: o.geometries.map(function (o) {\n        return feature$1(topology, o);\n      })\n    } : feature$1(topology, o);\n  }\n  function feature$1(topology, o) {\n    var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n    return id == null && bbox == null ? {\n      type: \"Feature\",\n      properties: properties,\n      geometry: geometry\n    } : bbox == null ? {\n      type: \"Feature\",\n      id: id,\n      properties: properties,\n      geometry: geometry\n    } : {\n      type: \"Feature\",\n      id: id,\n      bbox: bbox,\n      properties: properties,\n      geometry: geometry\n    };\n  }\n  function object(topology, o) {\n    var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n    function arc(i, points) {\n      if (points.length) points.pop();\n      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n        points.push(transformPoint(a[k], k));\n      }\n      if (i < 0) reverse(points, n);\n    }\n    function point(p) {\n      return transformPoint(p);\n    }\n    function line(arcs) {\n      var points = [];\n      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n      if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n      return points;\n    }\n    function ring(arcs) {\n      var points = line(arcs);\n      while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n      return points;\n    }\n    function polygon(arcs) {\n      return arcs.map(ring);\n    }\n    function geometry(o) {\n      var type = o.type,\n        coordinates;\n      switch (type) {\n        case \"GeometryCollection\":\n          return {\n            type: type,\n            geometries: o.geometries.map(geometry)\n          };\n        case \"Point\":\n          coordinates = point(o.coordinates);\n          break;\n        case \"MultiPoint\":\n          coordinates = o.coordinates.map(point);\n          break;\n        case \"LineString\":\n          coordinates = line(o.arcs);\n          break;\n        case \"MultiLineString\":\n          coordinates = o.arcs.map(line);\n          break;\n        case \"Polygon\":\n          coordinates = polygon(o.arcs);\n          break;\n        case \"MultiPolygon\":\n          coordinates = o.arcs.map(polygon);\n          break;\n        default:\n          return null;\n      }\n      return {\n        type: type,\n        coordinates: coordinates\n      };\n    }\n    return geometry(o);\n  }\n  function stitch(topology, arcs) {\n    var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n    // Stitch empty arcs first, since they may be subsumed by other arcs.\n    arcs.forEach(function (i, j) {\n      var arc = topology.arcs[i < 0 ? ~i : i],\n        t;\n      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n      }\n    });\n    arcs.forEach(function (i) {\n      var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f,\n        g;\n      if (f = fragmentByEnd[start]) {\n        delete fragmentByEnd[f.end];\n        f.push(i);\n        f.end = end;\n        if (g = fragmentByStart[end]) {\n          delete fragmentByStart[g.start];\n          var fg = g === f ? f : f.concat(g);\n          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else if (f = fragmentByStart[end]) {\n        delete fragmentByStart[f.start];\n        f.unshift(i);\n        f.start = start;\n        if (g = fragmentByEnd[start]) {\n          delete fragmentByEnd[g.end];\n          var gf = g === f ? f : g.concat(f);\n          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else {\n        f = [i];\n        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n      }\n    });\n    function ends(i) {\n      var arc = topology.arcs[i < 0 ? ~i : i],\n        p0 = arc[0],\n        p1;\n      if (topology.transform) p1 = [0, 0], arc.forEach(function (dp) {\n        p1[0] += dp[0], p1[1] += dp[1];\n      });else p1 = arc[arc.length - 1];\n      return i < 0 ? [p1, p0] : [p0, p1];\n    }\n    function flush(fragmentByEnd, fragmentByStart) {\n      for (var k in fragmentByEnd) {\n        var f = fragmentByEnd[k];\n        delete fragmentByStart[f.start];\n        delete f.start;\n        delete f.end;\n        f.forEach(function (i) {\n          stitchedArcs[i < 0 ? ~i : i] = 1;\n        });\n        fragments.push(f);\n      }\n    }\n    flush(fragmentByEnd, fragmentByStart);\n    flush(fragmentByStart, fragmentByEnd);\n    arcs.forEach(function (i) {\n      if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);\n    });\n    return fragments;\n  }\n  function mesh(topology) {\n    return object(topology, meshArcs.apply(this, arguments));\n  }\n  function meshArcs(topology, object, filter) {\n    var arcs, i, n;\n    if (arguments.length > 1) arcs = extractArcs(topology, object, filter);else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n    return {\n      type: \"MultiLineString\",\n      arcs: stitch(topology, arcs)\n    };\n  }\n  function extractArcs(topology, object, filter) {\n    var arcs = [],\n      geomsByArc = [],\n      geom;\n    function extract0(i) {\n      var j = i < 0 ? ~i : i;\n      (geomsByArc[j] || (geomsByArc[j] = [])).push({\n        i: i,\n        g: geom\n      });\n    }\n    function extract1(arcs) {\n      arcs.forEach(extract0);\n    }\n    function extract2(arcs) {\n      arcs.forEach(extract1);\n    }\n    function extract3(arcs) {\n      arcs.forEach(extract2);\n    }\n    function geometry(o) {\n      switch (geom = o, o.type) {\n        case \"GeometryCollection\":\n          o.geometries.forEach(geometry);\n          break;\n        case \"LineString\":\n          extract1(o.arcs);\n          break;\n        case \"MultiLineString\":\n        case \"Polygon\":\n          extract2(o.arcs);\n          break;\n        case \"MultiPolygon\":\n          extract3(o.arcs);\n          break;\n      }\n    }\n    geometry(object);\n    geomsByArc.forEach(filter == null ? function (geoms) {\n      arcs.push(geoms[0].i);\n    } : function (geoms) {\n      if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);\n    });\n    return arcs;\n  }\n  function planarRingArea(ring) {\n    var i = -1,\n      n = ring.length,\n      a,\n      b = ring[n - 1],\n      area = 0;\n    while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n    return Math.abs(area); // Note: doubled area!\n  }\n\n  function merge(topology) {\n    return object(topology, mergeArcs.apply(this, arguments));\n  }\n  function mergeArcs(topology, objects) {\n    var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n    objects.forEach(geometry);\n    function geometry(o) {\n      switch (o.type) {\n        case \"GeometryCollection\":\n          o.geometries.forEach(geometry);\n          break;\n        case \"Polygon\":\n          extract(o.arcs);\n          break;\n        case \"MultiPolygon\":\n          o.arcs.forEach(extract);\n          break;\n      }\n    }\n    function extract(polygon) {\n      polygon.forEach(function (ring) {\n        ring.forEach(function (arc) {\n          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n        });\n      });\n      polygons.push(polygon);\n    }\n    function area(ring) {\n      return planarRingArea(object(topology, {\n        type: \"Polygon\",\n        arcs: [ring]\n      }).coordinates[0]);\n    }\n    polygons.forEach(function (polygon) {\n      if (!polygon._) {\n        var group = [],\n          neighbors = [polygon];\n        polygon._ = 1;\n        groups.push(group);\n        while (polygon = neighbors.pop()) {\n          group.push(polygon);\n          polygon.forEach(function (ring) {\n            ring.forEach(function (arc) {\n              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {\n                if (!polygon._) {\n                  polygon._ = 1;\n                  neighbors.push(polygon);\n                }\n              });\n            });\n          });\n        }\n      }\n    });\n    polygons.forEach(function (polygon) {\n      delete polygon._;\n    });\n    return {\n      type: \"MultiPolygon\",\n      arcs: groups.map(function (polygons) {\n        var arcs = [],\n          n;\n\n        // Extract the exterior (unique) arcs.\n        polygons.forEach(function (polygon) {\n          polygon.forEach(function (ring) {\n            ring.forEach(function (arc) {\n              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n                arcs.push(arc);\n              }\n            });\n          });\n        });\n\n        // Stitch the arcs into one or more rings.\n        arcs = stitch(topology, arcs);\n\n        // If more than one ring is returned,\n        // at most one of these rings can be the exterior;\n        // choose the one with the greatest absolute area.\n        if ((n = arcs.length) > 1) {\n          for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n            if ((ki = area(arcs[i])) > k) {\n              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n            }\n          }\n        }\n        return arcs;\n      }).filter(function (arcs) {\n        return arcs.length > 0;\n      })\n    };\n  }\n  function bisect(a, x) {\n    var lo = 0,\n      hi = a.length;\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (a[mid] < x) lo = mid + 1;else hi = mid;\n    }\n    return lo;\n  }\n  function neighbors(objects) {\n    var indexesByArc = {},\n      // arc index -> array of object indexes\n      neighbors = objects.map(function () {\n        return [];\n      });\n    function line(arcs, i) {\n      arcs.forEach(function (a) {\n        if (a < 0) a = ~a;\n        var o = indexesByArc[a];\n        if (o) o.push(i);else indexesByArc[a] = [i];\n      });\n    }\n    function polygon(arcs, i) {\n      arcs.forEach(function (arc) {\n        line(arc, i);\n      });\n    }\n    function geometry(o, i) {\n      if (o.type === \"GeometryCollection\") o.geometries.forEach(function (o) {\n        geometry(o, i);\n      });else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n    }\n    var geometryType = {\n      LineString: line,\n      MultiLineString: polygon,\n      Polygon: polygon,\n      MultiPolygon: function (arcs, i) {\n        arcs.forEach(function (arc) {\n          polygon(arc, i);\n        });\n      }\n    };\n    objects.forEach(geometry);\n    for (var i in indexesByArc) {\n      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n        for (var k = j + 1; k < m; ++k) {\n          var ij = indexes[j],\n            ik = indexes[k],\n            n;\n          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n        }\n      }\n    }\n    return neighbors;\n  }\n  function untransform(transform) {\n    if (transform == null) return identity;\n    var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n    return function (input, i) {\n      if (!i) x0 = y0 = 0;\n      var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n      output[0] = x1 - x0, x0 = x1;\n      output[1] = y1 - y0, y0 = y1;\n      while (j < n) output[j] = input[j], ++j;\n      return output;\n    };\n  }\n  function quantize(topology, transform) {\n    if (topology.transform) throw new Error(\"already quantized\");\n    if (!transform || !transform.scale) {\n      if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n      box = topology.bbox || bbox(topology);\n      var x0 = box[0],\n        y0 = box[1],\n        x1 = box[2],\n        y1 = box[3],\n        n;\n      transform = {\n        scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1],\n        translate: [x0, y0]\n      };\n    } else {\n      box = topology.bbox;\n    }\n    var t = untransform(transform),\n      box,\n      key,\n      inputs = topology.objects,\n      outputs = {};\n    function quantizePoint(point) {\n      return t(point);\n    }\n    function quantizeGeometry(input) {\n      var output;\n      switch (input.type) {\n        case \"GeometryCollection\":\n          output = {\n            type: \"GeometryCollection\",\n            geometries: input.geometries.map(quantizeGeometry)\n          };\n          break;\n        case \"Point\":\n          output = {\n            type: \"Point\",\n            coordinates: quantizePoint(input.coordinates)\n          };\n          break;\n        case \"MultiPoint\":\n          output = {\n            type: \"MultiPoint\",\n            coordinates: input.coordinates.map(quantizePoint)\n          };\n          break;\n        default:\n          return input;\n      }\n      if (input.id != null) output.id = input.id;\n      if (input.bbox != null) output.bbox = input.bbox;\n      if (input.properties != null) output.properties = input.properties;\n      return output;\n    }\n    function quantizeArc(input) {\n      var i = 0,\n        j = 1,\n        n = input.length,\n        p,\n        output = new Array(n); // pessimistic\n      output[0] = t(input[0], 0);\n      while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n      if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n      output.length = j;\n      return output;\n    }\n    for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n    return {\n      type: \"Topology\",\n      bbox: box,\n      transform: transform,\n      objects: outputs,\n      arcs: topology.arcs.map(quantizeArc)\n    };\n  }\n  exports.bbox = bbox;\n  exports.feature = feature;\n  exports.merge = merge;\n  exports.mergeArcs = mergeArcs;\n  exports.mesh = mesh;\n  exports.meshArcs = meshArcs;\n  exports.neighbors = neighbors;\n  exports.quantize = quantize;\n  exports.transform = transform;\n  exports.untransform = untransform;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","self","topojson","identity","x","transform","x0","y0","kx","scale","ky","dx","translate","dy","input","i","j","n","length","output","Array","bbox","topology","t","key","Infinity","x1","y1","bboxPoint","p","bboxGeometry","o","type","geometries","forEach","coordinates","arcs","arc","objects","reverse","array","feature","features","map","feature$1","id","properties","geometry","object","transformPoint","points","pop","a","k","push","point","line","ring","polygon","stitch","stitchedArcs","fragmentByStart","fragmentByEnd","fragments","emptyIndex","e","ends","start","end","f","g","fg","concat","unshift","gf","p0","p1","dp","flush","mesh","meshArcs","apply","arguments","filter","extractArcs","geomsByArc","geom","extract0","extract1","extract2","extract3","geoms","planarRingArea","b","area","Math","abs","merge","mergeArcs","polygonsByArc","polygons","groups","extract","_","group","neighbors","ki","bisect","lo","hi","mid","indexesByArc","geometryType","LineString","MultiLineString","Polygon","MultiPolygon","indexes","m","ij","ik","splice","untransform","round","quantize","Error","floor","box","inputs","outputs","quantizePoint","quantizeGeometry","quantizeArc","Object","defineProperty","value"],"sources":["C:/Users/johns/OneDrive/桌面/practice/map/node_modules/topojson-client/dist/topojson-client.js"],"sourcesContent":["// https://github.com/topojson/topojson-client v3.1.0 Copyright 2019 Mike Bostock\n(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\ntypeof define === 'function' && define.amd ? define(['exports'], factory) :\n(global = global || self, factory(global.topojson = global.topojson || {}));\n}(this, function (exports) { 'use strict';\n\nfunction identity(x) {\n  return x;\n}\n\nfunction transform(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n\nfunction bbox(topology) {\n  var t = transform(topology.transform), key,\n      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n  function bboxPoint(p) {\n    p = t(p);\n    if (p[0] < x0) x0 = p[0];\n    if (p[0] > x1) x1 = p[0];\n    if (p[1] < y0) y0 = p[1];\n    if (p[1] > y1) y1 = p[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = -1, n = arc.length, p;\n    while (++i < n) {\n      p = t(arc[i], i);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n  });\n\n  for (key in topology.objects) {\n    bboxGeometry(topology.objects[key]);\n  }\n\n  return [x0, y0, x1, y1];\n}\n\nfunction reverse(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n\nfunction feature(topology, o) {\n  if (typeof o === \"string\") o = topology.objects[o];\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$1(topology, o); })}\n      : feature$1(topology, o);\n}\n\nfunction feature$1(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nfunction object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n\nfunction stitch(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n}\n\nfunction mesh(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n}\n\nfunction meshArcs(topology, object, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nfunction merge(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\n\nfunction mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    }).filter(function(arcs) {\n      return arcs.length > 0;\n    })\n  };\n}\n\nfunction bisect(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n\nfunction neighbors(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n}\n\nfunction untransform(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n    output[0] = x1 - x0, x0 = x1;\n    output[1] = y1 - y0, y0 = y1;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n\nfunction quantize(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n\nexports.bbox = bbox;\nexports.feature = feature;\nexports.merge = merge;\nexports.mergeArcs = mergeArcs;\nexports.mesh = mesh;\nexports.meshArcs = meshArcs;\nexports.neighbors = neighbors;\nexports.quantize = quantize;\nexports.transform = transform;\nexports.untransform = untransform;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],"mappings":"AAAA;AACC,WAAUA,MAAM,EAAEC,OAAO,EAAE;EAC5B,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOC,MAAM,KAAK,WAAW,GAAGF,OAAO,CAACC,OAAO,CAAC,GAC/E,OAAOE,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,GAAG,GAAGD,MAAM,CAAC,CAAC,SAAS,CAAC,EAAEH,OAAO,CAAC,IACxED,MAAM,GAAGA,MAAM,IAAIM,IAAI,EAAEL,OAAO,CAACD,MAAM,CAACO,QAAQ,GAAGP,MAAM,CAACO,QAAQ,IAAI,CAAC,CAAC,CAAC,CAAC;AAC3E,CAAC,EAAC,IAAI,EAAE,UAAUL,OAAO,EAAE;EAAE,YAAY;;EAEzC,SAASM,QAAQA,CAACC,CAAC,EAAE;IACnB,OAAOA,CAAC;EACV;EAEA,SAASC,SAASA,CAACA,SAAS,EAAE;IAC5B,IAAIA,SAAS,IAAI,IAAI,EAAE,OAAOF,QAAQ;IACtC,IAAIG,EAAE;MACFC,EAAE;MACFC,EAAE,GAAGH,SAAS,CAACI,KAAK,CAAC,CAAC,CAAC;MACvBC,EAAE,GAAGL,SAAS,CAACI,KAAK,CAAC,CAAC,CAAC;MACvBE,EAAE,GAAGN,SAAS,CAACO,SAAS,CAAC,CAAC,CAAC;MAC3BC,EAAE,GAAGR,SAAS,CAACO,SAAS,CAAC,CAAC,CAAC;IAC/B,OAAO,UAASE,KAAK,EAAEC,CAAC,EAAE;MACxB,IAAI,CAACA,CAAC,EAAET,EAAE,GAAGC,EAAE,GAAG,CAAC;MACnB,IAAIS,CAAC,GAAG,CAAC;QAAEC,CAAC,GAAGH,KAAK,CAACI,MAAM;QAAEC,MAAM,GAAG,IAAIC,KAAK,CAACH,CAAC,CAAC;MAClDE,MAAM,CAAC,CAAC,CAAC,GAAG,CAACb,EAAE,IAAIQ,KAAK,CAAC,CAAC,CAAC,IAAIN,EAAE,GAAGG,EAAE;MACtCQ,MAAM,CAAC,CAAC,CAAC,GAAG,CAACZ,EAAE,IAAIO,KAAK,CAAC,CAAC,CAAC,IAAIJ,EAAE,GAAGG,EAAE;MACtC,OAAOG,CAAC,GAAGC,CAAC,EAAEE,MAAM,CAACH,CAAC,CAAC,GAAGF,KAAK,CAACE,CAAC,CAAC,EAAE,EAAEA,CAAC;MACvC,OAAOG,MAAM;IACf,CAAC;EACH;EAEA,SAASE,IAAIA,CAACC,QAAQ,EAAE;IACtB,IAAIC,CAAC,GAAGlB,SAAS,CAACiB,QAAQ,CAACjB,SAAS,CAAC;MAAEmB,GAAG;MACtClB,EAAE,GAAGmB,QAAQ;MAAElB,EAAE,GAAGD,EAAE;MAAEoB,EAAE,GAAG,CAACpB,EAAE;MAAEqB,EAAE,GAAG,CAACrB,EAAE;IAE9C,SAASsB,SAASA,CAACC,CAAC,EAAE;MACpBA,CAAC,GAAGN,CAAC,CAACM,CAAC,CAAC;MACR,IAAIA,CAAC,CAAC,CAAC,CAAC,GAAGvB,EAAE,EAAEA,EAAE,GAAGuB,CAAC,CAAC,CAAC,CAAC;MACxB,IAAIA,CAAC,CAAC,CAAC,CAAC,GAAGH,EAAE,EAAEA,EAAE,GAAGG,CAAC,CAAC,CAAC,CAAC;MACxB,IAAIA,CAAC,CAAC,CAAC,CAAC,GAAGtB,EAAE,EAAEA,EAAE,GAAGsB,CAAC,CAAC,CAAC,CAAC;MACxB,IAAIA,CAAC,CAAC,CAAC,CAAC,GAAGF,EAAE,EAAEA,EAAE,GAAGE,CAAC,CAAC,CAAC,CAAC;IAC1B;IAEA,SAASC,YAAYA,CAACC,CAAC,EAAE;MACvB,QAAQA,CAAC,CAACC,IAAI;QACZ,KAAK,oBAAoB;UAAED,CAAC,CAACE,UAAU,CAACC,OAAO,CAACJ,YAAY,CAAC;UAAE;QAC/D,KAAK,OAAO;UAAEF,SAAS,CAACG,CAAC,CAACI,WAAW,CAAC;UAAE;QACxC,KAAK,YAAY;UAAEJ,CAAC,CAACI,WAAW,CAACD,OAAO,CAACN,SAAS,CAAC;UAAE;MACvD;IACF;IAEAN,QAAQ,CAACc,IAAI,CAACF,OAAO,CAAC,UAASG,GAAG,EAAE;MAClC,IAAItB,CAAC,GAAG,CAAC,CAAC;QAAEE,CAAC,GAAGoB,GAAG,CAACnB,MAAM;QAAEW,CAAC;MAC7B,OAAO,EAAEd,CAAC,GAAGE,CAAC,EAAE;QACdY,CAAC,GAAGN,CAAC,CAACc,GAAG,CAACtB,CAAC,CAAC,EAAEA,CAAC,CAAC;QAChB,IAAIc,CAAC,CAAC,CAAC,CAAC,GAAGvB,EAAE,EAAEA,EAAE,GAAGuB,CAAC,CAAC,CAAC,CAAC;QACxB,IAAIA,CAAC,CAAC,CAAC,CAAC,GAAGH,EAAE,EAAEA,EAAE,GAAGG,CAAC,CAAC,CAAC,CAAC;QACxB,IAAIA,CAAC,CAAC,CAAC,CAAC,GAAGtB,EAAE,EAAEA,EAAE,GAAGsB,CAAC,CAAC,CAAC,CAAC;QACxB,IAAIA,CAAC,CAAC,CAAC,CAAC,GAAGF,EAAE,EAAEA,EAAE,GAAGE,CAAC,CAAC,CAAC,CAAC;MAC1B;IACF,CAAC,CAAC;IAEF,KAAKL,GAAG,IAAIF,QAAQ,CAACgB,OAAO,EAAE;MAC5BR,YAAY,CAACR,QAAQ,CAACgB,OAAO,CAACd,GAAG,CAAC,CAAC;IACrC;IAEA,OAAO,CAAClB,EAAE,EAAEC,EAAE,EAAEmB,EAAE,EAAEC,EAAE,CAAC;EACzB;EAEA,SAASY,OAAOA,CAACC,KAAK,EAAEvB,CAAC,EAAE;IACzB,IAAIM,CAAC;MAAEP,CAAC,GAAGwB,KAAK,CAACtB,MAAM;MAAEH,CAAC,GAAGC,CAAC,GAAGC,CAAC;IAClC,OAAOF,CAAC,GAAG,EAAEC,CAAC,EAAEO,CAAC,GAAGiB,KAAK,CAACzB,CAAC,CAAC,EAAEyB,KAAK,CAACzB,CAAC,EAAE,CAAC,GAAGyB,KAAK,CAACxB,CAAC,CAAC,EAAEwB,KAAK,CAACxB,CAAC,CAAC,GAAGO,CAAC;EACnE;EAEA,SAASkB,OAAOA,CAACnB,QAAQ,EAAES,CAAC,EAAE;IAC5B,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAEA,CAAC,GAAGT,QAAQ,CAACgB,OAAO,CAACP,CAAC,CAAC;IAClD,OAAOA,CAAC,CAACC,IAAI,KAAK,oBAAoB,GAChC;MAACA,IAAI,EAAE,mBAAmB;MAAEU,QAAQ,EAAEX,CAAC,CAACE,UAAU,CAACU,GAAG,CAAC,UAASZ,CAAC,EAAE;QAAE,OAAOa,SAAS,CAACtB,QAAQ,EAAES,CAAC,CAAC;MAAE,CAAC;IAAC,CAAC,GACvGa,SAAS,CAACtB,QAAQ,EAAES,CAAC,CAAC;EAC9B;EAEA,SAASa,SAASA,CAACtB,QAAQ,EAAES,CAAC,EAAE;IAC9B,IAAIc,EAAE,GAAGd,CAAC,CAACc,EAAE;MACTxB,IAAI,GAAGU,CAAC,CAACV,IAAI;MACbyB,UAAU,GAAGf,CAAC,CAACe,UAAU,IAAI,IAAI,GAAG,CAAC,CAAC,GAAGf,CAAC,CAACe,UAAU;MACrDC,QAAQ,GAAGC,MAAM,CAAC1B,QAAQ,EAAES,CAAC,CAAC;IAClC,OAAOc,EAAE,IAAI,IAAI,IAAIxB,IAAI,IAAI,IAAI,GAAG;MAACW,IAAI,EAAE,SAAS;MAAEc,UAAU,EAAEA,UAAU;MAAEC,QAAQ,EAAEA;IAAQ,CAAC,GAC3F1B,IAAI,IAAI,IAAI,GAAG;MAACW,IAAI,EAAE,SAAS;MAAEa,EAAE,EAAEA,EAAE;MAAEC,UAAU,EAAEA,UAAU;MAAEC,QAAQ,EAAEA;IAAQ,CAAC,GACpF;MAACf,IAAI,EAAE,SAAS;MAAEa,EAAE,EAAEA,EAAE;MAAExB,IAAI,EAAEA,IAAI;MAAEyB,UAAU,EAAEA,UAAU;MAAEC,QAAQ,EAAEA;IAAQ,CAAC;EACzF;EAEA,SAASC,MAAMA,CAAC1B,QAAQ,EAAES,CAAC,EAAE;IAC3B,IAAIkB,cAAc,GAAG5C,SAAS,CAACiB,QAAQ,CAACjB,SAAS,CAAC;MAC9C+B,IAAI,GAAGd,QAAQ,CAACc,IAAI;IAExB,SAASC,GAAGA,CAACtB,CAAC,EAAEmC,MAAM,EAAE;MACtB,IAAIA,MAAM,CAAChC,MAAM,EAAEgC,MAAM,CAACC,GAAG,CAAC,CAAC;MAC/B,KAAK,IAAIC,CAAC,GAAGhB,IAAI,CAACrB,CAAC,GAAG,CAAC,GAAG,CAACA,CAAC,GAAGA,CAAC,CAAC,EAAEsC,CAAC,GAAG,CAAC,EAAEpC,CAAC,GAAGmC,CAAC,CAAClC,MAAM,EAAEmC,CAAC,GAAGpC,CAAC,EAAE,EAAEoC,CAAC,EAAE;QAClEH,MAAM,CAACI,IAAI,CAACL,cAAc,CAACG,CAAC,CAACC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC;MACtC;MACA,IAAItC,CAAC,GAAG,CAAC,EAAEwB,OAAO,CAACW,MAAM,EAAEjC,CAAC,CAAC;IAC/B;IAEA,SAASsC,KAAKA,CAAC1B,CAAC,EAAE;MAChB,OAAOoB,cAAc,CAACpB,CAAC,CAAC;IAC1B;IAEA,SAAS2B,IAAIA,CAACpB,IAAI,EAAE;MAClB,IAAIc,MAAM,GAAG,EAAE;MACf,KAAK,IAAInC,CAAC,GAAG,CAAC,EAAEE,CAAC,GAAGmB,IAAI,CAAClB,MAAM,EAAEH,CAAC,GAAGE,CAAC,EAAE,EAAEF,CAAC,EAAEsB,GAAG,CAACD,IAAI,CAACrB,CAAC,CAAC,EAAEmC,MAAM,CAAC;MACjE,IAAIA,MAAM,CAAChC,MAAM,GAAG,CAAC,EAAEgC,MAAM,CAACI,IAAI,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAC/C,OAAOA,MAAM;IACf;IAEA,SAASO,IAAIA,CAACrB,IAAI,EAAE;MAClB,IAAIc,MAAM,GAAGM,IAAI,CAACpB,IAAI,CAAC;MACvB,OAAOc,MAAM,CAAChC,MAAM,GAAG,CAAC,EAAEgC,MAAM,CAACI,IAAI,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAClD,OAAOA,MAAM;IACf;IAEA,SAASQ,OAAOA,CAACtB,IAAI,EAAE;MACrB,OAAOA,IAAI,CAACO,GAAG,CAACc,IAAI,CAAC;IACvB;IAEA,SAASV,QAAQA,CAAChB,CAAC,EAAE;MACnB,IAAIC,IAAI,GAAGD,CAAC,CAACC,IAAI;QAAEG,WAAW;MAC9B,QAAQH,IAAI;QACV,KAAK,oBAAoB;UAAE,OAAO;YAACA,IAAI,EAAEA,IAAI;YAAEC,UAAU,EAAEF,CAAC,CAACE,UAAU,CAACU,GAAG,CAACI,QAAQ;UAAC,CAAC;QACtF,KAAK,OAAO;UAAEZ,WAAW,GAAGoB,KAAK,CAACxB,CAAC,CAACI,WAAW,CAAC;UAAE;QAClD,KAAK,YAAY;UAAEA,WAAW,GAAGJ,CAAC,CAACI,WAAW,CAACQ,GAAG,CAACY,KAAK,CAAC;UAAE;QAC3D,KAAK,YAAY;UAAEpB,WAAW,GAAGqB,IAAI,CAACzB,CAAC,CAACK,IAAI,CAAC;UAAE;QAC/C,KAAK,iBAAiB;UAAED,WAAW,GAAGJ,CAAC,CAACK,IAAI,CAACO,GAAG,CAACa,IAAI,CAAC;UAAE;QACxD,KAAK,SAAS;UAAErB,WAAW,GAAGuB,OAAO,CAAC3B,CAAC,CAACK,IAAI,CAAC;UAAE;QAC/C,KAAK,cAAc;UAAED,WAAW,GAAGJ,CAAC,CAACK,IAAI,CAACO,GAAG,CAACe,OAAO,CAAC;UAAE;QACxD;UAAS,OAAO,IAAI;MACtB;MACA,OAAO;QAAC1B,IAAI,EAAEA,IAAI;QAAEG,WAAW,EAAEA;MAAW,CAAC;IAC/C;IAEA,OAAOY,QAAQ,CAAChB,CAAC,CAAC;EACpB;EAEA,SAAS4B,MAAMA,CAACrC,QAAQ,EAAEc,IAAI,EAAE;IAC9B,IAAIwB,YAAY,GAAG,CAAC,CAAC;MACjBC,eAAe,GAAG,CAAC,CAAC;MACpBC,aAAa,GAAG,CAAC,CAAC;MAClBC,SAAS,GAAG,EAAE;MACdC,UAAU,GAAG,CAAC,CAAC;;IAEnB;IACA5B,IAAI,CAACF,OAAO,CAAC,UAASnB,CAAC,EAAEC,CAAC,EAAE;MAC1B,IAAIqB,GAAG,GAAGf,QAAQ,CAACc,IAAI,CAACrB,CAAC,GAAG,CAAC,GAAG,CAACA,CAAC,GAAGA,CAAC,CAAC;QAAEQ,CAAC;MAC1C,IAAIc,GAAG,CAACnB,MAAM,GAAG,CAAC,IAAI,CAACmB,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAACA,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;QAC9Cd,CAAC,GAAGa,IAAI,CAAC,EAAE4B,UAAU,CAAC,EAAE5B,IAAI,CAAC4B,UAAU,CAAC,GAAGjD,CAAC,EAAEqB,IAAI,CAACpB,CAAC,CAAC,GAAGO,CAAC;MAC3D;IACF,CAAC,CAAC;IAEFa,IAAI,CAACF,OAAO,CAAC,UAASnB,CAAC,EAAE;MACvB,IAAIkD,CAAC,GAAGC,IAAI,CAACnD,CAAC,CAAC;QACXoD,KAAK,GAAGF,CAAC,CAAC,CAAC,CAAC;QACZG,GAAG,GAAGH,CAAC,CAAC,CAAC,CAAC;QACVI,CAAC;QAAEC,CAAC;MAER,IAAID,CAAC,GAAGP,aAAa,CAACK,KAAK,CAAC,EAAE;QAC5B,OAAOL,aAAa,CAACO,CAAC,CAACD,GAAG,CAAC;QAC3BC,CAAC,CAACf,IAAI,CAACvC,CAAC,CAAC;QACTsD,CAAC,CAACD,GAAG,GAAGA,GAAG;QACX,IAAIE,CAAC,GAAGT,eAAe,CAACO,GAAG,CAAC,EAAE;UAC5B,OAAOP,eAAe,CAACS,CAAC,CAACH,KAAK,CAAC;UAC/B,IAAII,EAAE,GAAGD,CAAC,KAAKD,CAAC,GAAGA,CAAC,GAAGA,CAAC,CAACG,MAAM,CAACF,CAAC,CAAC;UAClCT,eAAe,CAACU,EAAE,CAACJ,KAAK,GAAGE,CAAC,CAACF,KAAK,CAAC,GAAGL,aAAa,CAACS,EAAE,CAACH,GAAG,GAAGE,CAAC,CAACF,GAAG,CAAC,GAAGG,EAAE;QAC1E,CAAC,MAAM;UACLV,eAAe,CAACQ,CAAC,CAACF,KAAK,CAAC,GAAGL,aAAa,CAACO,CAAC,CAACD,GAAG,CAAC,GAAGC,CAAC;QACrD;MACF,CAAC,MAAM,IAAIA,CAAC,GAAGR,eAAe,CAACO,GAAG,CAAC,EAAE;QACnC,OAAOP,eAAe,CAACQ,CAAC,CAACF,KAAK,CAAC;QAC/BE,CAAC,CAACI,OAAO,CAAC1D,CAAC,CAAC;QACZsD,CAAC,CAACF,KAAK,GAAGA,KAAK;QACf,IAAIG,CAAC,GAAGR,aAAa,CAACK,KAAK,CAAC,EAAE;UAC5B,OAAOL,aAAa,CAACQ,CAAC,CAACF,GAAG,CAAC;UAC3B,IAAIM,EAAE,GAAGJ,CAAC,KAAKD,CAAC,GAAGA,CAAC,GAAGC,CAAC,CAACE,MAAM,CAACH,CAAC,CAAC;UAClCR,eAAe,CAACa,EAAE,CAACP,KAAK,GAAGG,CAAC,CAACH,KAAK,CAAC,GAAGL,aAAa,CAACY,EAAE,CAACN,GAAG,GAAGC,CAAC,CAACD,GAAG,CAAC,GAAGM,EAAE;QAC1E,CAAC,MAAM;UACLb,eAAe,CAACQ,CAAC,CAACF,KAAK,CAAC,GAAGL,aAAa,CAACO,CAAC,CAACD,GAAG,CAAC,GAAGC,CAAC;QACrD;MACF,CAAC,MAAM;QACLA,CAAC,GAAG,CAACtD,CAAC,CAAC;QACP8C,eAAe,CAACQ,CAAC,CAACF,KAAK,GAAGA,KAAK,CAAC,GAAGL,aAAa,CAACO,CAAC,CAACD,GAAG,GAAGA,GAAG,CAAC,GAAGC,CAAC;MACnE;IACF,CAAC,CAAC;IAEF,SAASH,IAAIA,CAACnD,CAAC,EAAE;MACf,IAAIsB,GAAG,GAAGf,QAAQ,CAACc,IAAI,CAACrB,CAAC,GAAG,CAAC,GAAG,CAACA,CAAC,GAAGA,CAAC,CAAC;QAAE4D,EAAE,GAAGtC,GAAG,CAAC,CAAC,CAAC;QAAEuC,EAAE;MACxD,IAAItD,QAAQ,CAACjB,SAAS,EAAEuE,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEvC,GAAG,CAACH,OAAO,CAAC,UAAS2C,EAAE,EAAE;QAAED,EAAE,CAAC,CAAC,CAAC,IAAIC,EAAE,CAAC,CAAC,CAAC,EAAED,EAAE,CAAC,CAAC,CAAC,IAAIC,EAAE,CAAC,CAAC,CAAC;MAAE,CAAC,CAAC,CAAC,KAC9FD,EAAE,GAAGvC,GAAG,CAACA,GAAG,CAACnB,MAAM,GAAG,CAAC,CAAC;MAC7B,OAAOH,CAAC,GAAG,CAAC,GAAG,CAAC6D,EAAE,EAAED,EAAE,CAAC,GAAG,CAACA,EAAE,EAAEC,EAAE,CAAC;IACpC;IAEA,SAASE,KAAKA,CAAChB,aAAa,EAAED,eAAe,EAAE;MAC7C,KAAK,IAAIR,CAAC,IAAIS,aAAa,EAAE;QAC3B,IAAIO,CAAC,GAAGP,aAAa,CAACT,CAAC,CAAC;QACxB,OAAOQ,eAAe,CAACQ,CAAC,CAACF,KAAK,CAAC;QAC/B,OAAOE,CAAC,CAACF,KAAK;QACd,OAAOE,CAAC,CAACD,GAAG;QACZC,CAAC,CAACnC,OAAO,CAAC,UAASnB,CAAC,EAAE;UAAE6C,YAAY,CAAC7C,CAAC,GAAG,CAAC,GAAG,CAACA,CAAC,GAAGA,CAAC,CAAC,GAAG,CAAC;QAAE,CAAC,CAAC;QAC5DgD,SAAS,CAACT,IAAI,CAACe,CAAC,CAAC;MACnB;IACF;IAEAS,KAAK,CAAChB,aAAa,EAAED,eAAe,CAAC;IACrCiB,KAAK,CAACjB,eAAe,EAAEC,aAAa,CAAC;IACrC1B,IAAI,CAACF,OAAO,CAAC,UAASnB,CAAC,EAAE;MAAE,IAAI,CAAC6C,YAAY,CAAC7C,CAAC,GAAG,CAAC,GAAG,CAACA,CAAC,GAAGA,CAAC,CAAC,EAAEgD,SAAS,CAACT,IAAI,CAAC,CAACvC,CAAC,CAAC,CAAC;IAAE,CAAC,CAAC;IAErF,OAAOgD,SAAS;EAClB;EAEA,SAASgB,IAAIA,CAACzD,QAAQ,EAAE;IACtB,OAAO0B,MAAM,CAAC1B,QAAQ,EAAE0D,QAAQ,CAACC,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC,CAAC;EAC1D;EAEA,SAASF,QAAQA,CAAC1D,QAAQ,EAAE0B,MAAM,EAAEmC,MAAM,EAAE;IAC1C,IAAI/C,IAAI,EAAErB,CAAC,EAAEE,CAAC;IACd,IAAIiE,SAAS,CAAChE,MAAM,GAAG,CAAC,EAAEkB,IAAI,GAAGgD,WAAW,CAAC9D,QAAQ,EAAE0B,MAAM,EAAEmC,MAAM,CAAC,CAAC,KAClE,KAAKpE,CAAC,GAAG,CAAC,EAAEqB,IAAI,GAAG,IAAIhB,KAAK,CAACH,CAAC,GAAGK,QAAQ,CAACc,IAAI,CAAClB,MAAM,CAAC,EAAEH,CAAC,GAAGE,CAAC,EAAE,EAAEF,CAAC,EAAEqB,IAAI,CAACrB,CAAC,CAAC,GAAGA,CAAC;IACpF,OAAO;MAACiB,IAAI,EAAE,iBAAiB;MAAEI,IAAI,EAAEuB,MAAM,CAACrC,QAAQ,EAAEc,IAAI;IAAC,CAAC;EAChE;EAEA,SAASgD,WAAWA,CAAC9D,QAAQ,EAAE0B,MAAM,EAAEmC,MAAM,EAAE;IAC7C,IAAI/C,IAAI,GAAG,EAAE;MACTiD,UAAU,GAAG,EAAE;MACfC,IAAI;IAER,SAASC,QAAQA,CAACxE,CAAC,EAAE;MACnB,IAAIC,CAAC,GAAGD,CAAC,GAAG,CAAC,GAAG,CAACA,CAAC,GAAGA,CAAC;MACtB,CAACsE,UAAU,CAACrE,CAAC,CAAC,KAAKqE,UAAU,CAACrE,CAAC,CAAC,GAAG,EAAE,CAAC,EAAEsC,IAAI,CAAC;QAACvC,CAAC,EAAEA,CAAC;QAAEuD,CAAC,EAAEgB;MAAI,CAAC,CAAC;IAC/D;IAEA,SAASE,QAAQA,CAACpD,IAAI,EAAE;MACtBA,IAAI,CAACF,OAAO,CAACqD,QAAQ,CAAC;IACxB;IAEA,SAASE,QAAQA,CAACrD,IAAI,EAAE;MACtBA,IAAI,CAACF,OAAO,CAACsD,QAAQ,CAAC;IACxB;IAEA,SAASE,QAAQA,CAACtD,IAAI,EAAE;MACtBA,IAAI,CAACF,OAAO,CAACuD,QAAQ,CAAC;IACxB;IAEA,SAAS1C,QAAQA,CAAChB,CAAC,EAAE;MACnB,QAAQuD,IAAI,GAAGvD,CAAC,EAAEA,CAAC,CAACC,IAAI;QACtB,KAAK,oBAAoB;UAAED,CAAC,CAACE,UAAU,CAACC,OAAO,CAACa,QAAQ,CAAC;UAAE;QAC3D,KAAK,YAAY;UAAEyC,QAAQ,CAACzD,CAAC,CAACK,IAAI,CAAC;UAAE;QACrC,KAAK,iBAAiB;QAAE,KAAK,SAAS;UAAEqD,QAAQ,CAAC1D,CAAC,CAACK,IAAI,CAAC;UAAE;QAC1D,KAAK,cAAc;UAAEsD,QAAQ,CAAC3D,CAAC,CAACK,IAAI,CAAC;UAAE;MACzC;IACF;IAEAW,QAAQ,CAACC,MAAM,CAAC;IAEhBqC,UAAU,CAACnD,OAAO,CAACiD,MAAM,IAAI,IAAI,GAC3B,UAASQ,KAAK,EAAE;MAAEvD,IAAI,CAACkB,IAAI,CAACqC,KAAK,CAAC,CAAC,CAAC,CAAC5E,CAAC,CAAC;IAAE,CAAC,GAC1C,UAAS4E,KAAK,EAAE;MAAE,IAAIR,MAAM,CAACQ,KAAK,CAAC,CAAC,CAAC,CAACrB,CAAC,EAAEqB,KAAK,CAACA,KAAK,CAACzE,MAAM,GAAG,CAAC,CAAC,CAACoD,CAAC,CAAC,EAAElC,IAAI,CAACkB,IAAI,CAACqC,KAAK,CAAC,CAAC,CAAC,CAAC5E,CAAC,CAAC;IAAE,CAAC,CAAC;IAEpG,OAAOqB,IAAI;EACb;EAEA,SAASwD,cAAcA,CAACnC,IAAI,EAAE;IAC5B,IAAI1C,CAAC,GAAG,CAAC,CAAC;MAAEE,CAAC,GAAGwC,IAAI,CAACvC,MAAM;MAAEkC,CAAC;MAAEyC,CAAC,GAAGpC,IAAI,CAACxC,CAAC,GAAG,CAAC,CAAC;MAAE6E,IAAI,GAAG,CAAC;IACzD,OAAO,EAAE/E,CAAC,GAAGE,CAAC,EAAEmC,CAAC,GAAGyC,CAAC,EAAEA,CAAC,GAAGpC,IAAI,CAAC1C,CAAC,CAAC,EAAE+E,IAAI,IAAI1C,CAAC,CAAC,CAAC,CAAC,GAAGyC,CAAC,CAAC,CAAC,CAAC,GAAGzC,CAAC,CAAC,CAAC,CAAC,GAAGyC,CAAC,CAAC,CAAC,CAAC;IACrE,OAAOE,IAAI,CAACC,GAAG,CAACF,IAAI,CAAC,CAAC,CAAC;EACzB;;EAEA,SAASG,KAAKA,CAAC3E,QAAQ,EAAE;IACvB,OAAO0B,MAAM,CAAC1B,QAAQ,EAAE4E,SAAS,CAACjB,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC,CAAC;EAC3D;EAEA,SAASgB,SAASA,CAAC5E,QAAQ,EAAEgB,OAAO,EAAE;IACpC,IAAI6D,aAAa,GAAG,CAAC,CAAC;MAClBC,QAAQ,GAAG,EAAE;MACbC,MAAM,GAAG,EAAE;IAEf/D,OAAO,CAACJ,OAAO,CAACa,QAAQ,CAAC;IAEzB,SAASA,QAAQA,CAAChB,CAAC,EAAE;MACnB,QAAQA,CAAC,CAACC,IAAI;QACZ,KAAK,oBAAoB;UAAED,CAAC,CAACE,UAAU,CAACC,OAAO,CAACa,QAAQ,CAAC;UAAE;QAC3D,KAAK,SAAS;UAAEuD,OAAO,CAACvE,CAAC,CAACK,IAAI,CAAC;UAAE;QACjC,KAAK,cAAc;UAAEL,CAAC,CAACK,IAAI,CAACF,OAAO,CAACoE,OAAO,CAAC;UAAE;MAChD;IACF;IAEA,SAASA,OAAOA,CAAC5C,OAAO,EAAE;MACxBA,OAAO,CAACxB,OAAO,CAAC,UAASuB,IAAI,EAAE;QAC7BA,IAAI,CAACvB,OAAO,CAAC,UAASG,GAAG,EAAE;UACzB,CAAC8D,aAAa,CAAC9D,GAAG,GAAGA,GAAG,GAAG,CAAC,GAAG,CAACA,GAAG,GAAGA,GAAG,CAAC,KAAK8D,aAAa,CAAC9D,GAAG,CAAC,GAAG,EAAE,CAAC,EAAEiB,IAAI,CAACI,OAAO,CAAC;QACxF,CAAC,CAAC;MACJ,CAAC,CAAC;MACF0C,QAAQ,CAAC9C,IAAI,CAACI,OAAO,CAAC;IACxB;IAEA,SAASoC,IAAIA,CAACrC,IAAI,EAAE;MAClB,OAAOmC,cAAc,CAAC5C,MAAM,CAAC1B,QAAQ,EAAE;QAACU,IAAI,EAAE,SAAS;QAAEI,IAAI,EAAE,CAACqB,IAAI;MAAC,CAAC,CAAC,CAACtB,WAAW,CAAC,CAAC,CAAC,CAAC;IACzF;IAEAiE,QAAQ,CAAClE,OAAO,CAAC,UAASwB,OAAO,EAAE;MACjC,IAAI,CAACA,OAAO,CAAC6C,CAAC,EAAE;QACd,IAAIC,KAAK,GAAG,EAAE;UACVC,SAAS,GAAG,CAAC/C,OAAO,CAAC;QACzBA,OAAO,CAAC6C,CAAC,GAAG,CAAC;QACbF,MAAM,CAAC/C,IAAI,CAACkD,KAAK,CAAC;QAClB,OAAO9C,OAAO,GAAG+C,SAAS,CAACtD,GAAG,CAAC,CAAC,EAAE;UAChCqD,KAAK,CAAClD,IAAI,CAACI,OAAO,CAAC;UACnBA,OAAO,CAACxB,OAAO,CAAC,UAASuB,IAAI,EAAE;YAC7BA,IAAI,CAACvB,OAAO,CAAC,UAASG,GAAG,EAAE;cACzB8D,aAAa,CAAC9D,GAAG,GAAG,CAAC,GAAG,CAACA,GAAG,GAAGA,GAAG,CAAC,CAACH,OAAO,CAAC,UAASwB,OAAO,EAAE;gBAC5D,IAAI,CAACA,OAAO,CAAC6C,CAAC,EAAE;kBACd7C,OAAO,CAAC6C,CAAC,GAAG,CAAC;kBACbE,SAAS,CAACnD,IAAI,CAACI,OAAO,CAAC;gBACzB;cACF,CAAC,CAAC;YACJ,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ;MACF;IACF,CAAC,CAAC;IAEF0C,QAAQ,CAAClE,OAAO,CAAC,UAASwB,OAAO,EAAE;MACjC,OAAOA,OAAO,CAAC6C,CAAC;IAClB,CAAC,CAAC;IAEF,OAAO;MACLvE,IAAI,EAAE,cAAc;MACpBI,IAAI,EAAEiE,MAAM,CAAC1D,GAAG,CAAC,UAASyD,QAAQ,EAAE;QAClC,IAAIhE,IAAI,GAAG,EAAE;UAAEnB,CAAC;;QAEhB;QACAmF,QAAQ,CAAClE,OAAO,CAAC,UAASwB,OAAO,EAAE;UACjCA,OAAO,CAACxB,OAAO,CAAC,UAASuB,IAAI,EAAE;YAC7BA,IAAI,CAACvB,OAAO,CAAC,UAASG,GAAG,EAAE;cACzB,IAAI8D,aAAa,CAAC9D,GAAG,GAAG,CAAC,GAAG,CAACA,GAAG,GAAGA,GAAG,CAAC,CAACnB,MAAM,GAAG,CAAC,EAAE;gBAClDkB,IAAI,CAACkB,IAAI,CAACjB,GAAG,CAAC;cAChB;YACF,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ,CAAC,CAAC;;QAEF;QACAD,IAAI,GAAGuB,MAAM,CAACrC,QAAQ,EAAEc,IAAI,CAAC;;QAE7B;QACA;QACA;QACA,IAAI,CAACnB,CAAC,GAAGmB,IAAI,CAAClB,MAAM,IAAI,CAAC,EAAE;UACzB,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEsC,CAAC,GAAGyC,IAAI,CAAC1D,IAAI,CAAC,CAAC,CAAC,CAAC,EAAEsE,EAAE,EAAEnF,CAAC,EAAER,CAAC,GAAGE,CAAC,EAAE,EAAEF,CAAC,EAAE;YACpD,IAAI,CAAC2F,EAAE,GAAGZ,IAAI,CAAC1D,IAAI,CAACrB,CAAC,CAAC,CAAC,IAAIsC,CAAC,EAAE;cAC5B9B,CAAC,GAAGa,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAACrB,CAAC,CAAC,EAAEqB,IAAI,CAACrB,CAAC,CAAC,GAAGQ,CAAC,EAAE8B,CAAC,GAAGqD,EAAE;YACrD;UACF;QACF;QAEA,OAAOtE,IAAI;MACb,CAAC,CAAC,CAAC+C,MAAM,CAAC,UAAS/C,IAAI,EAAE;QACvB,OAAOA,IAAI,CAAClB,MAAM,GAAG,CAAC;MACxB,CAAC;IACH,CAAC;EACH;EAEA,SAASyF,MAAMA,CAACvD,CAAC,EAAEhD,CAAC,EAAE;IACpB,IAAIwG,EAAE,GAAG,CAAC;MAAEC,EAAE,GAAGzD,CAAC,CAAClC,MAAM;IACzB,OAAO0F,EAAE,GAAGC,EAAE,EAAE;MACd,IAAIC,GAAG,GAAGF,EAAE,GAAGC,EAAE,KAAK,CAAC;MACvB,IAAIzD,CAAC,CAAC0D,GAAG,CAAC,GAAG1G,CAAC,EAAEwG,EAAE,GAAGE,GAAG,GAAG,CAAC,CAAC,KACxBD,EAAE,GAAGC,GAAG;IACf;IACA,OAAOF,EAAE;EACX;EAEA,SAASH,SAASA,CAACnE,OAAO,EAAE;IAC1B,IAAIyE,YAAY,GAAG,CAAC,CAAC;MAAE;MACnBN,SAAS,GAAGnE,OAAO,CAACK,GAAG,CAAC,YAAW;QAAE,OAAO,EAAE;MAAE,CAAC,CAAC;IAEtD,SAASa,IAAIA,CAACpB,IAAI,EAAErB,CAAC,EAAE;MACrBqB,IAAI,CAACF,OAAO,CAAC,UAASkB,CAAC,EAAE;QACvB,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAACA,CAAC;QACjB,IAAIrB,CAAC,GAAGgF,YAAY,CAAC3D,CAAC,CAAC;QACvB,IAAIrB,CAAC,EAAEA,CAAC,CAACuB,IAAI,CAACvC,CAAC,CAAC,CAAC,KACZgG,YAAY,CAAC3D,CAAC,CAAC,GAAG,CAACrC,CAAC,CAAC;MAC5B,CAAC,CAAC;IACJ;IAEA,SAAS2C,OAAOA,CAACtB,IAAI,EAAErB,CAAC,EAAE;MACxBqB,IAAI,CAACF,OAAO,CAAC,UAASG,GAAG,EAAE;QAAEmB,IAAI,CAACnB,GAAG,EAAEtB,CAAC,CAAC;MAAE,CAAC,CAAC;IAC/C;IAEA,SAASgC,QAAQA,CAAChB,CAAC,EAAEhB,CAAC,EAAE;MACtB,IAAIgB,CAAC,CAACC,IAAI,KAAK,oBAAoB,EAAED,CAAC,CAACE,UAAU,CAACC,OAAO,CAAC,UAASH,CAAC,EAAE;QAAEgB,QAAQ,CAAChB,CAAC,EAAEhB,CAAC,CAAC;MAAE,CAAC,CAAC,CAAC,KACtF,IAAIgB,CAAC,CAACC,IAAI,IAAIgF,YAAY,EAAEA,YAAY,CAACjF,CAAC,CAACC,IAAI,CAAC,CAACD,CAAC,CAACK,IAAI,EAAErB,CAAC,CAAC;IAClE;IAEA,IAAIiG,YAAY,GAAG;MACjBC,UAAU,EAAEzD,IAAI;MAChB0D,eAAe,EAAExD,OAAO;MACxByD,OAAO,EAAEzD,OAAO;MAChB0D,YAAY,EAAE,SAAAA,CAAShF,IAAI,EAAErB,CAAC,EAAE;QAAEqB,IAAI,CAACF,OAAO,CAAC,UAASG,GAAG,EAAE;UAAEqB,OAAO,CAACrB,GAAG,EAAEtB,CAAC,CAAC;QAAE,CAAC,CAAC;MAAE;IACtF,CAAC;IAEDuB,OAAO,CAACJ,OAAO,CAACa,QAAQ,CAAC;IAEzB,KAAK,IAAIhC,CAAC,IAAIgG,YAAY,EAAE;MAC1B,KAAK,IAAIM,OAAO,GAAGN,YAAY,CAAChG,CAAC,CAAC,EAAEuG,CAAC,GAAGD,OAAO,CAACnG,MAAM,EAAEF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsG,CAAC,EAAE,EAAEtG,CAAC,EAAE;QACzE,KAAK,IAAIqC,CAAC,GAAGrC,CAAC,GAAG,CAAC,EAAEqC,CAAC,GAAGiE,CAAC,EAAE,EAAEjE,CAAC,EAAE;UAC9B,IAAIkE,EAAE,GAAGF,OAAO,CAACrG,CAAC,CAAC;YAAEwG,EAAE,GAAGH,OAAO,CAAChE,CAAC,CAAC;YAAEpC,CAAC;UACvC,IAAI,CAACA,CAAC,GAAGwF,SAAS,CAACc,EAAE,CAAC,EAAExG,CAAC,GAAG4F,MAAM,CAAC1F,CAAC,EAAEuG,EAAE,CAAC,CAAC,KAAKA,EAAE,EAAEvG,CAAC,CAACwG,MAAM,CAAC1G,CAAC,EAAE,CAAC,EAAEyG,EAAE,CAAC;UACrE,IAAI,CAACvG,CAAC,GAAGwF,SAAS,CAACe,EAAE,CAAC,EAAEzG,CAAC,GAAG4F,MAAM,CAAC1F,CAAC,EAAEsG,EAAE,CAAC,CAAC,KAAKA,EAAE,EAAEtG,CAAC,CAACwG,MAAM,CAAC1G,CAAC,EAAE,CAAC,EAAEwG,EAAE,CAAC;QACvE;MACF;IACF;IAEA,OAAOd,SAAS;EAClB;EAEA,SAASiB,WAAWA,CAACrH,SAAS,EAAE;IAC9B,IAAIA,SAAS,IAAI,IAAI,EAAE,OAAOF,QAAQ;IACtC,IAAIG,EAAE;MACFC,EAAE;MACFC,EAAE,GAAGH,SAAS,CAACI,KAAK,CAAC,CAAC,CAAC;MACvBC,EAAE,GAAGL,SAAS,CAACI,KAAK,CAAC,CAAC,CAAC;MACvBE,EAAE,GAAGN,SAAS,CAACO,SAAS,CAAC,CAAC,CAAC;MAC3BC,EAAE,GAAGR,SAAS,CAACO,SAAS,CAAC,CAAC,CAAC;IAC/B,OAAO,UAASE,KAAK,EAAEC,CAAC,EAAE;MACxB,IAAI,CAACA,CAAC,EAAET,EAAE,GAAGC,EAAE,GAAG,CAAC;MACnB,IAAIS,CAAC,GAAG,CAAC;QACLC,CAAC,GAAGH,KAAK,CAACI,MAAM;QAChBC,MAAM,GAAG,IAAIC,KAAK,CAACH,CAAC,CAAC;QACrBS,EAAE,GAAGqE,IAAI,CAAC4B,KAAK,CAAC,CAAC7G,KAAK,CAAC,CAAC,CAAC,GAAGH,EAAE,IAAIH,EAAE,CAAC;QACrCmB,EAAE,GAAGoE,IAAI,CAAC4B,KAAK,CAAC,CAAC7G,KAAK,CAAC,CAAC,CAAC,GAAGD,EAAE,IAAIH,EAAE,CAAC;MACzCS,MAAM,CAAC,CAAC,CAAC,GAAGO,EAAE,GAAGpB,EAAE,EAAEA,EAAE,GAAGoB,EAAE;MAC5BP,MAAM,CAAC,CAAC,CAAC,GAAGQ,EAAE,GAAGpB,EAAE,EAAEA,EAAE,GAAGoB,EAAE;MAC5B,OAAOX,CAAC,GAAGC,CAAC,EAAEE,MAAM,CAACH,CAAC,CAAC,GAAGF,KAAK,CAACE,CAAC,CAAC,EAAE,EAAEA,CAAC;MACvC,OAAOG,MAAM;IACf,CAAC;EACH;EAEA,SAASyG,QAAQA,CAACtG,QAAQ,EAAEjB,SAAS,EAAE;IACrC,IAAIiB,QAAQ,CAACjB,SAAS,EAAE,MAAM,IAAIwH,KAAK,CAAC,mBAAmB,CAAC;IAE5D,IAAI,CAACxH,SAAS,IAAI,CAACA,SAAS,CAACI,KAAK,EAAE;MAClC,IAAI,EAAE,CAACQ,CAAC,GAAG8E,IAAI,CAAC+B,KAAK,CAACzH,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,IAAIwH,KAAK,CAAC,cAAc,CAAC;MACxEE,GAAG,GAAGzG,QAAQ,CAACD,IAAI,IAAIA,IAAI,CAACC,QAAQ,CAAC;MACrC,IAAIhB,EAAE,GAAGyH,GAAG,CAAC,CAAC,CAAC;QAAExH,EAAE,GAAGwH,GAAG,CAAC,CAAC,CAAC;QAAErG,EAAE,GAAGqG,GAAG,CAAC,CAAC,CAAC;QAAEpG,EAAE,GAAGoG,GAAG,CAAC,CAAC,CAAC;QAAE9G,CAAC;MACzDZ,SAAS,GAAG;QAACI,KAAK,EAAE,CAACiB,EAAE,GAAGpB,EAAE,GAAG,CAACoB,EAAE,GAAGpB,EAAE,KAAKW,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAEU,EAAE,GAAGpB,EAAE,GAAG,CAACoB,EAAE,GAAGpB,EAAE,KAAKU,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QAAEL,SAAS,EAAE,CAACN,EAAE,EAAEC,EAAE;MAAC,CAAC;IAClH,CAAC,MAAM;MACLwH,GAAG,GAAGzG,QAAQ,CAACD,IAAI;IACrB;IAEA,IAAIE,CAAC,GAAGmG,WAAW,CAACrH,SAAS,CAAC;MAAE0H,GAAG;MAAEvG,GAAG;MAAEwG,MAAM,GAAG1G,QAAQ,CAACgB,OAAO;MAAE2F,OAAO,GAAG,CAAC,CAAC;IAEjF,SAASC,aAAaA,CAAC3E,KAAK,EAAE;MAC5B,OAAOhC,CAAC,CAACgC,KAAK,CAAC;IACjB;IAEA,SAAS4E,gBAAgBA,CAACrH,KAAK,EAAE;MAC/B,IAAIK,MAAM;MACV,QAAQL,KAAK,CAACkB,IAAI;QAChB,KAAK,oBAAoB;UAAEb,MAAM,GAAG;YAACa,IAAI,EAAE,oBAAoB;YAAEC,UAAU,EAAEnB,KAAK,CAACmB,UAAU,CAACU,GAAG,CAACwF,gBAAgB;UAAC,CAAC;UAAE;QACtH,KAAK,OAAO;UAAEhH,MAAM,GAAG;YAACa,IAAI,EAAE,OAAO;YAAEG,WAAW,EAAE+F,aAAa,CAACpH,KAAK,CAACqB,WAAW;UAAC,CAAC;UAAE;QACvF,KAAK,YAAY;UAAEhB,MAAM,GAAG;YAACa,IAAI,EAAE,YAAY;YAAEG,WAAW,EAAErB,KAAK,CAACqB,WAAW,CAACQ,GAAG,CAACuF,aAAa;UAAC,CAAC;UAAE;QACrG;UAAS,OAAOpH,KAAK;MACvB;MACA,IAAIA,KAAK,CAAC+B,EAAE,IAAI,IAAI,EAAE1B,MAAM,CAAC0B,EAAE,GAAG/B,KAAK,CAAC+B,EAAE;MAC1C,IAAI/B,KAAK,CAACO,IAAI,IAAI,IAAI,EAAEF,MAAM,CAACE,IAAI,GAAGP,KAAK,CAACO,IAAI;MAChD,IAAIP,KAAK,CAACgC,UAAU,IAAI,IAAI,EAAE3B,MAAM,CAAC2B,UAAU,GAAGhC,KAAK,CAACgC,UAAU;MAClE,OAAO3B,MAAM;IACf;IAEA,SAASiH,WAAWA,CAACtH,KAAK,EAAE;MAC1B,IAAIC,CAAC,GAAG,CAAC;QAAEC,CAAC,GAAG,CAAC;QAAEC,CAAC,GAAGH,KAAK,CAACI,MAAM;QAAEW,CAAC;QAAEV,MAAM,GAAG,IAAIC,KAAK,CAACH,CAAC,CAAC,CAAC,CAAC;MAC9DE,MAAM,CAAC,CAAC,CAAC,GAAGI,CAAC,CAACT,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;MAC1B,OAAO,EAAEC,CAAC,GAAGE,CAAC,EAAE,IAAI,CAACY,CAAC,GAAGN,CAAC,CAACT,KAAK,CAACC,CAAC,CAAC,EAAEA,CAAC,CAAC,EAAE,CAAC,CAAC,IAAIc,CAAC,CAAC,CAAC,CAAC,EAAEV,MAAM,CAACH,CAAC,EAAE,CAAC,GAAGa,CAAC,CAAC,CAAC;MACtE,IAAIb,CAAC,KAAK,CAAC,EAAEG,MAAM,CAACH,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MACnCG,MAAM,CAACD,MAAM,GAAGF,CAAC;MACjB,OAAOG,MAAM;IACf;IAEA,KAAKK,GAAG,IAAIwG,MAAM,EAAEC,OAAO,CAACzG,GAAG,CAAC,GAAG2G,gBAAgB,CAACH,MAAM,CAACxG,GAAG,CAAC,CAAC;IAEhE,OAAO;MACLQ,IAAI,EAAE,UAAU;MAChBX,IAAI,EAAE0G,GAAG;MACT1H,SAAS,EAAEA,SAAS;MACpBiC,OAAO,EAAE2F,OAAO;MAChB7F,IAAI,EAAEd,QAAQ,CAACc,IAAI,CAACO,GAAG,CAACyF,WAAW;IACrC,CAAC;EACH;EAEAvI,OAAO,CAACwB,IAAI,GAAGA,IAAI;EACnBxB,OAAO,CAAC4C,OAAO,GAAGA,OAAO;EACzB5C,OAAO,CAACoG,KAAK,GAAGA,KAAK;EACrBpG,OAAO,CAACqG,SAAS,GAAGA,SAAS;EAC7BrG,OAAO,CAACkF,IAAI,GAAGA,IAAI;EACnBlF,OAAO,CAACmF,QAAQ,GAAGA,QAAQ;EAC3BnF,OAAO,CAAC4G,SAAS,GAAGA,SAAS;EAC7B5G,OAAO,CAAC+H,QAAQ,GAAGA,QAAQ;EAC3B/H,OAAO,CAACQ,SAAS,GAAGA,SAAS;EAC7BR,OAAO,CAAC6H,WAAW,GAAGA,WAAW;EAEjCW,MAAM,CAACC,cAAc,CAACzI,OAAO,EAAE,YAAY,EAAE;IAAE0I,KAAK,EAAE;EAAK,CAAC,CAAC;AAE7D,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}