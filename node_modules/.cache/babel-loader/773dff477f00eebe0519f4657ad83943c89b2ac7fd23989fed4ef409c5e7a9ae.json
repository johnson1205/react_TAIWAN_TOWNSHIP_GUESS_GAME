{"ast":null,"code":"import { transform } from \"topojson-client\";\nimport newHeap from \"./heap\";\nimport { planarTriangleArea } from \"./planar\";\nfunction copy(point) {\n  return [point[0], point[1], 0];\n}\nexport default function (topology, weight) {\n  var point = topology.transform ? transform(topology.transform) : copy,\n    heap = newHeap();\n  if (weight == null) weight = planarTriangleArea;\n  var arcs = topology.arcs.map(function (arc) {\n    var triangles = [],\n      maxWeight = 0,\n      triangle,\n      i,\n      n;\n    arc = arc.map(point);\n    for (i = 1, n = arc.length - 1; i < n; ++i) {\n      triangle = [arc[i - 1], arc[i], arc[i + 1]];\n      triangle[1][2] = weight(triangle);\n      triangles.push(triangle);\n      heap.push(triangle);\n    }\n\n    // Always keep the arc endpoints!\n    arc[0][2] = arc[n][2] = Infinity;\n    for (i = 0, n = triangles.length; i < n; ++i) {\n      triangle = triangles[i];\n      triangle.previous = triangles[i - 1];\n      triangle.next = triangles[i + 1];\n    }\n    while (triangle = heap.pop()) {\n      var previous = triangle.previous,\n        next = triangle.next;\n\n      // If the weight of the current point is less than that of the previous\n      // point to be eliminated, use the latter’s weight instead. This ensures\n      // that the current point cannot be eliminated without eliminating\n      // previously- eliminated points.\n      if (triangle[1][2] < maxWeight) triangle[1][2] = maxWeight;else maxWeight = triangle[1][2];\n      if (previous) {\n        previous.next = next;\n        previous[2] = triangle[2];\n        update(previous);\n      }\n      if (next) {\n        next.previous = previous;\n        next[0] = triangle[0];\n        update(next);\n      }\n    }\n    return arc;\n  });\n  function update(triangle) {\n    heap.remove(triangle);\n    triangle[1][2] = weight(triangle);\n    heap.push(triangle);\n  }\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n}","map":{"version":3,"names":["transform","newHeap","planarTriangleArea","copy","point","topology","weight","heap","arcs","map","arc","triangles","maxWeight","triangle","i","n","length","push","Infinity","previous","next","pop","update","remove","type","bbox","objects"],"sources":["C:/Users/johns/OneDrive/桌面/practice/map/node_modules/topojson-simplify/src/presimplify.js"],"sourcesContent":["import {transform} from \"topojson-client\";\nimport newHeap from \"./heap\";\nimport {planarTriangleArea} from \"./planar\";\n\nfunction copy(point) {\n  return [point[0], point[1], 0];\n}\n\nexport default function(topology, weight) {\n  var point = topology.transform ? transform(topology.transform) : copy,\n      heap = newHeap();\n\n  if (weight == null) weight = planarTriangleArea;\n\n  var arcs = topology.arcs.map(function(arc) {\n    var triangles = [],\n        maxWeight = 0,\n        triangle,\n        i,\n        n;\n\n    arc = arc.map(point);\n\n    for (i = 1, n = arc.length - 1; i < n; ++i) {\n      triangle = [arc[i - 1], arc[i], arc[i + 1]];\n      triangle[1][2] = weight(triangle);\n      triangles.push(triangle);\n      heap.push(triangle);\n    }\n\n    // Always keep the arc endpoints!\n    arc[0][2] = arc[n][2] = Infinity;\n\n    for (i = 0, n = triangles.length; i < n; ++i) {\n      triangle = triangles[i];\n      triangle.previous = triangles[i - 1];\n      triangle.next = triangles[i + 1];\n    }\n\n    while (triangle = heap.pop()) {\n      var previous = triangle.previous,\n          next = triangle.next;\n\n      // If the weight of the current point is less than that of the previous\n      // point to be eliminated, use the latter’s weight instead. This ensures\n      // that the current point cannot be eliminated without eliminating\n      // previously- eliminated points.\n      if (triangle[1][2] < maxWeight) triangle[1][2] = maxWeight;\n      else maxWeight = triangle[1][2];\n\n      if (previous) {\n        previous.next = next;\n        previous[2] = triangle[2];\n        update(previous);\n      }\n\n      if (next) {\n        next.previous = previous;\n        next[0] = triangle[0];\n        update(next);\n      }\n    }\n\n    return arc;\n  });\n\n  function update(triangle) {\n    heap.remove(triangle);\n    triangle[1][2] = weight(triangle);\n    heap.push(triangle);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}