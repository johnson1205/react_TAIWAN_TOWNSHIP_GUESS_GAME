{"ast":null,"code":"import prune from \"./prune\";\nexport default function (topology, filter) {\n  var oldObjects = topology.objects,\n    newObjects = {},\n    key;\n  if (filter == null) filter = filterTrue;\n  function filterGeometry(input) {\n    var output, arcs;\n    switch (input.type) {\n      case \"Polygon\":\n        {\n          arcs = filterRings(input.arcs);\n          output = arcs ? {\n            type: \"Polygon\",\n            arcs: arcs\n          } : {\n            type: null\n          };\n          break;\n        }\n      case \"MultiPolygon\":\n        {\n          arcs = input.arcs.map(filterRings).filter(filterIdentity);\n          output = arcs.length ? {\n            type: \"MultiPolygon\",\n            arcs: arcs\n          } : {\n            type: null\n          };\n          break;\n        }\n      case \"GeometryCollection\":\n        {\n          arcs = input.geometries.map(filterGeometry).filter(filterNotNull);\n          output = arcs.length ? {\n            type: \"GeometryCollection\",\n            geometries: arcs\n          } : {\n            type: null\n          };\n          break;\n        }\n      default:\n        return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n  function filterRings(arcs) {\n    return arcs.length && filterExteriorRing(arcs[0]) // if the exterior is small, ignore any holes\n    ? [arcs[0]].concat(arcs.slice(1).filter(filterInteriorRing)) : null;\n  }\n  function filterExteriorRing(ring) {\n    return filter(ring, false);\n  }\n  function filterInteriorRing(ring) {\n    return filter(ring, true);\n  }\n  for (key in oldObjects) {\n    newObjects[key] = filterGeometry(oldObjects[key]);\n  }\n  return prune({\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: topology.arcs\n  });\n}\nfunction filterTrue() {\n  return true;\n}\nfunction filterIdentity(x) {\n  return x;\n}\nfunction filterNotNull(geometry) {\n  return geometry.type != null;\n}","map":{"version":3,"names":["prune","topology","filter","oldObjects","objects","newObjects","key","filterTrue","filterGeometry","input","output","arcs","type","filterRings","map","filterIdentity","length","geometries","filterNotNull","id","bbox","properties","filterExteriorRing","concat","slice","filterInteriorRing","ring","transform","x","geometry"],"sources":["C:/Users/johns/OneDrive/桌面/practice/map/node_modules/topojson-simplify/src/filter.js"],"sourcesContent":["import prune from \"./prune\";\n\nexport default function(topology, filter) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      key;\n\n  if (filter == null) filter = filterTrue;\n\n  function filterGeometry(input) {\n    var output, arcs;\n    switch (input.type) {\n      case \"Polygon\": {\n        arcs = filterRings(input.arcs);\n        output = arcs ? {type: \"Polygon\", arcs: arcs} : {type: null};\n        break;\n      }\n      case \"MultiPolygon\": {\n        arcs = input.arcs.map(filterRings).filter(filterIdentity);\n        output = arcs.length ? {type: \"MultiPolygon\", arcs: arcs} : {type: null};\n        break;\n      }\n      case \"GeometryCollection\": {\n        arcs = input.geometries.map(filterGeometry).filter(filterNotNull);\n        output = arcs.length ? {type: \"GeometryCollection\", geometries: arcs} : {type: null};\n        break;\n      }\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function filterRings(arcs) {\n    return arcs.length && filterExteriorRing(arcs[0]) // if the exterior is small, ignore any holes\n        ? [arcs[0]].concat(arcs.slice(1).filter(filterInteriorRing))\n        : null;\n  }\n\n  function filterExteriorRing(ring) {\n    return filter(ring, false);\n  }\n\n  function filterInteriorRing(ring) {\n    return filter(ring, true);\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = filterGeometry(oldObjects[key]);\n  }\n\n  return prune({\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: topology.arcs\n  });\n}\n\nfunction filterTrue() {\n  return true;\n}\n\nfunction filterIdentity(x) {\n  return x;\n}\n\nfunction filterNotNull(geometry) {\n  return geometry.type != null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}