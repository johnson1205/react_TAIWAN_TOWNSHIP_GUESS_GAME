{"ast":null,"code":"export default function (topology) {\n  var oldObjects = topology.objects,\n    newObjects = {},\n    oldArcs = topology.arcs,\n    oldArcsLength = oldArcs.length,\n    oldIndex = -1,\n    newIndexByOldIndex = new Array(oldArcsLength),\n    newArcsLength = 0,\n    newArcs,\n    newIndex = -1,\n    key;\n  function scanGeometry(input) {\n    switch (input.type) {\n      case \"GeometryCollection\":\n        input.geometries.forEach(scanGeometry);\n        break;\n      case \"LineString\":\n        scanArcs(input.arcs);\n        break;\n      case \"MultiLineString\":\n        input.arcs.forEach(scanArcs);\n        break;\n      case \"Polygon\":\n        input.arcs.forEach(scanArcs);\n        break;\n      case \"MultiPolygon\":\n        input.arcs.forEach(scanMultiArcs);\n        break;\n    }\n  }\n  function scanArc(index) {\n    if (index < 0) index = ~index;\n    if (!newIndexByOldIndex[index]) newIndexByOldIndex[index] = 1, ++newArcsLength;\n  }\n  function scanArcs(arcs) {\n    arcs.forEach(scanArc);\n  }\n  function scanMultiArcs(arcs) {\n    arcs.forEach(scanArcs);\n  }\n  function reindexGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\":\n        output = {\n          type: \"GeometryCollection\",\n          geometries: input.geometries.map(reindexGeometry)\n        };\n        break;\n      case \"LineString\":\n        output = {\n          type: \"LineString\",\n          arcs: reindexArcs(input.arcs)\n        };\n        break;\n      case \"MultiLineString\":\n        output = {\n          type: \"MultiLineString\",\n          arcs: input.arcs.map(reindexArcs)\n        };\n        break;\n      case \"Polygon\":\n        output = {\n          type: \"Polygon\",\n          arcs: input.arcs.map(reindexArcs)\n        };\n        break;\n      case \"MultiPolygon\":\n        output = {\n          type: \"MultiPolygon\",\n          arcs: input.arcs.map(reindexMultiArcs)\n        };\n        break;\n      default:\n        return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n  function reindexArc(oldIndex) {\n    return oldIndex < 0 ? ~newIndexByOldIndex[~oldIndex] : newIndexByOldIndex[oldIndex];\n  }\n  function reindexArcs(arcs) {\n    return arcs.map(reindexArc);\n  }\n  function reindexMultiArcs(arcs) {\n    return arcs.map(reindexArcs);\n  }\n  for (key in oldObjects) {\n    scanGeometry(oldObjects[key]);\n  }\n  newArcs = new Array(newArcsLength);\n  while (++oldIndex < oldArcsLength) {\n    if (newIndexByOldIndex[oldIndex]) {\n      newIndexByOldIndex[oldIndex] = ++newIndex;\n      newArcs[newIndex] = oldArcs[oldIndex];\n    }\n  }\n  for (key in oldObjects) {\n    newObjects[key] = reindexGeometry(oldObjects[key]);\n  }\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: newArcs\n  };\n}","map":{"version":3,"names":["topology","oldObjects","objects","newObjects","oldArcs","arcs","oldArcsLength","length","oldIndex","newIndexByOldIndex","Array","newArcsLength","newArcs","newIndex","key","scanGeometry","input","type","geometries","forEach","scanArcs","scanMultiArcs","scanArc","index","reindexGeometry","output","map","reindexArcs","reindexMultiArcs","id","bbox","properties","reindexArc","transform"],"sources":["C:/Users/johns/OneDrive/桌面/practice/map/node_modules/topojson-simplify/src/prune.js"],"sourcesContent":["export default function(topology) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      oldArcs = topology.arcs,\n      oldArcsLength = oldArcs.length,\n      oldIndex = -1,\n      newIndexByOldIndex = new Array(oldArcsLength),\n      newArcsLength = 0,\n      newArcs,\n      newIndex = -1,\n      key;\n\n  function scanGeometry(input) {\n    switch (input.type) {\n      case \"GeometryCollection\": input.geometries.forEach(scanGeometry); break;\n      case \"LineString\": scanArcs(input.arcs); break;\n      case \"MultiLineString\": input.arcs.forEach(scanArcs); break;\n      case \"Polygon\": input.arcs.forEach(scanArcs); break;\n      case \"MultiPolygon\": input.arcs.forEach(scanMultiArcs); break;\n    }\n  }\n\n  function scanArc(index) {\n    if (index < 0) index = ~index;\n    if (!newIndexByOldIndex[index]) newIndexByOldIndex[index] = 1, ++newArcsLength;\n  }\n\n  function scanArcs(arcs) {\n    arcs.forEach(scanArc);\n  }\n\n  function scanMultiArcs(arcs) {\n    arcs.forEach(scanArcs);\n  }\n\n  function reindexGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(reindexGeometry)}; break;\n      case \"LineString\": output = {type: \"LineString\", arcs: reindexArcs(input.arcs)}; break;\n      case \"MultiLineString\": output = {type: \"MultiLineString\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"Polygon\": output = {type: \"Polygon\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"MultiPolygon\": output = {type: \"MultiPolygon\", arcs: input.arcs.map(reindexMultiArcs)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function reindexArc(oldIndex) {\n    return oldIndex < 0 ? ~newIndexByOldIndex[~oldIndex] : newIndexByOldIndex[oldIndex];\n  }\n\n  function reindexArcs(arcs) {\n    return arcs.map(reindexArc);\n  }\n\n  function reindexMultiArcs(arcs) {\n    return arcs.map(reindexArcs);\n  }\n\n  for (key in oldObjects) {\n    scanGeometry(oldObjects[key]);\n  }\n\n  newArcs = new Array(newArcsLength);\n\n  while (++oldIndex < oldArcsLength) {\n    if (newIndexByOldIndex[oldIndex]) {\n      newIndexByOldIndex[oldIndex] = ++newIndex;\n      newArcs[newIndex] = oldArcs[oldIndex];\n    }\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = reindexGeometry(oldObjects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: newArcs\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}