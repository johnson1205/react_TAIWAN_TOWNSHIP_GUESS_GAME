{"ast":null,"code":"// Extracts the lines and rings from the specified hash of geometry objects.\n//\n// Returns an object with three properties:\n//\n// * coordinates - shared buffer of [x, y] coordinates\n// * lines - lines extracted from the hash, of the form [start, end]\n// * rings - rings extracted from the hash, of the form [start, end]\n//\n// For each ring or line, start and end represent inclusive indexes into the\n// coordinates buffer. For rings (and closed lines), coordinates[start] equals\n// coordinates[end].\n//\n// For each line or polygon geometry in the input hash, including nested\n// geometries as in geometry collections, the `coordinates` array is replaced\n// with an equivalent `arcs` array that, for each line (for line string\n// geometries) or ring (for polygon geometries), points to one of the above\n// lines or rings.\nexport default function (objects) {\n  var index = -1,\n    lines = [],\n    rings = [],\n    coordinates = [];\n  function extractGeometry(geometry) {\n    if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);\n  }\n  var extractGeometryType = {\n    GeometryCollection: function (o) {\n      o.geometries.forEach(extractGeometry);\n    },\n    LineString: function (o) {\n      o.arcs = extractLine(o.arcs);\n    },\n    MultiLineString: function (o) {\n      o.arcs = o.arcs.map(extractLine);\n    },\n    Polygon: function (o) {\n      o.arcs = o.arcs.map(extractRing);\n    },\n    MultiPolygon: function (o) {\n      o.arcs = o.arcs.map(extractMultiRing);\n    }\n  };\n  function extractLine(line) {\n    for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];\n    var arc = {\n      0: index - n + 1,\n      1: index\n    };\n    lines.push(arc);\n    return arc;\n  }\n  function extractRing(ring) {\n    for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];\n    var arc = {\n      0: index - n + 1,\n      1: index\n    };\n    rings.push(arc);\n    return arc;\n  }\n  function extractMultiRing(rings) {\n    return rings.map(extractRing);\n  }\n  for (var key in objects) {\n    extractGeometry(objects[key]);\n  }\n  return {\n    type: \"Topology\",\n    coordinates: coordinates,\n    lines: lines,\n    rings: rings,\n    objects: objects\n  };\n}","map":{"version":3,"names":["objects","index","lines","rings","coordinates","extractGeometry","geometry","extractGeometryType","hasOwnProperty","type","GeometryCollection","o","geometries","forEach","LineString","arcs","extractLine","MultiLineString","map","Polygon","extractRing","MultiPolygon","extractMultiRing","line","i","n","length","arc","push","ring","key"],"sources":["C:/Users/johns/OneDrive/桌面/practice/map/node_modules/topojson-server/src/extract.js"],"sourcesContent":["// Extracts the lines and rings from the specified hash of geometry objects.\n//\n// Returns an object with three properties:\n//\n// * coordinates - shared buffer of [x, y] coordinates\n// * lines - lines extracted from the hash, of the form [start, end]\n// * rings - rings extracted from the hash, of the form [start, end]\n//\n// For each ring or line, start and end represent inclusive indexes into the\n// coordinates buffer. For rings (and closed lines), coordinates[start] equals\n// coordinates[end].\n//\n// For each line or polygon geometry in the input hash, including nested\n// geometries as in geometry collections, the `coordinates` array is replaced\n// with an equivalent `arcs` array that, for each line (for line string\n// geometries) or ring (for polygon geometries), points to one of the above\n// lines or rings.\nexport default function(objects) {\n  var index = -1,\n      lines = [],\n      rings = [],\n      coordinates = [];\n\n  function extractGeometry(geometry) {\n    if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);\n  }\n\n  var extractGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(extractGeometry); },\n    LineString: function(o) { o.arcs = extractLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(extractLine); },\n    Polygon: function(o) { o.arcs = o.arcs.map(extractRing); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(extractMultiRing); }\n  };\n\n  function extractLine(line) {\n    for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];\n    var arc = {0: index - n + 1, 1: index};\n    lines.push(arc);\n    return arc;\n  }\n\n  function extractRing(ring) {\n    for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];\n    var arc = {0: index - n + 1, 1: index};\n    rings.push(arc);\n    return arc;\n  }\n\n  function extractMultiRing(rings) {\n    return rings.map(extractRing);\n  }\n\n  for (var key in objects) {\n    extractGeometry(objects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    coordinates: coordinates,\n    lines: lines,\n    rings: rings,\n    objects: objects\n  };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAASA,OAAO,EAAE;EAC/B,IAAIC,KAAK,GAAG,CAAC,CAAC;IACVC,KAAK,GAAG,EAAE;IACVC,KAAK,GAAG,EAAE;IACVC,WAAW,GAAG,EAAE;EAEpB,SAASC,eAAeA,CAACC,QAAQ,EAAE;IACjC,IAAIA,QAAQ,IAAIC,mBAAmB,CAACC,cAAc,CAACF,QAAQ,CAACG,IAAI,CAAC,EAAEF,mBAAmB,CAACD,QAAQ,CAACG,IAAI,CAAC,CAACH,QAAQ,CAAC;EACjH;EAEA,IAAIC,mBAAmB,GAAG;IACxBG,kBAAkB,EAAE,SAAAA,CAASC,CAAC,EAAE;MAAEA,CAAC,CAACC,UAAU,CAACC,OAAO,CAACR,eAAe,CAAC;IAAE,CAAC;IAC1ES,UAAU,EAAE,SAAAA,CAASH,CAAC,EAAE;MAAEA,CAAC,CAACI,IAAI,GAAGC,WAAW,CAACL,CAAC,CAACI,IAAI,CAAC;IAAE,CAAC;IACzDE,eAAe,EAAE,SAAAA,CAASN,CAAC,EAAE;MAAEA,CAAC,CAACI,IAAI,GAAGJ,CAAC,CAACI,IAAI,CAACG,GAAG,CAACF,WAAW,CAAC;IAAE,CAAC;IAClEG,OAAO,EAAE,SAAAA,CAASR,CAAC,EAAE;MAAEA,CAAC,CAACI,IAAI,GAAGJ,CAAC,CAACI,IAAI,CAACG,GAAG,CAACE,WAAW,CAAC;IAAE,CAAC;IAC1DC,YAAY,EAAE,SAAAA,CAASV,CAAC,EAAE;MAAEA,CAAC,CAACI,IAAI,GAAGJ,CAAC,CAACI,IAAI,CAACG,GAAG,CAACI,gBAAgB,CAAC;IAAE;EACrE,CAAC;EAED,SAASN,WAAWA,CAACO,IAAI,EAAE;IACzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGF,IAAI,CAACG,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAE,EAAED,CAAC,EAAEpB,WAAW,CAAC,EAAEH,KAAK,CAAC,GAAGsB,IAAI,CAACC,CAAC,CAAC;IAC3E,IAAIG,GAAG,GAAG;MAAC,CAAC,EAAE1B,KAAK,GAAGwB,CAAC,GAAG,CAAC;MAAE,CAAC,EAAExB;IAAK,CAAC;IACtCC,KAAK,CAAC0B,IAAI,CAACD,GAAG,CAAC;IACf,OAAOA,GAAG;EACZ;EAEA,SAASP,WAAWA,CAACS,IAAI,EAAE;IACzB,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGI,IAAI,CAACH,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAE,EAAED,CAAC,EAAEpB,WAAW,CAAC,EAAEH,KAAK,CAAC,GAAG4B,IAAI,CAACL,CAAC,CAAC;IAC3E,IAAIG,GAAG,GAAG;MAAC,CAAC,EAAE1B,KAAK,GAAGwB,CAAC,GAAG,CAAC;MAAE,CAAC,EAAExB;IAAK,CAAC;IACtCE,KAAK,CAACyB,IAAI,CAACD,GAAG,CAAC;IACf,OAAOA,GAAG;EACZ;EAEA,SAASL,gBAAgBA,CAACnB,KAAK,EAAE;IAC/B,OAAOA,KAAK,CAACe,GAAG,CAACE,WAAW,CAAC;EAC/B;EAEA,KAAK,IAAIU,GAAG,IAAI9B,OAAO,EAAE;IACvBK,eAAe,CAACL,OAAO,CAAC8B,GAAG,CAAC,CAAC;EAC/B;EAEA,OAAO;IACLrB,IAAI,EAAE,UAAU;IAChBL,WAAW,EAAEA,WAAW;IACxBF,KAAK,EAAEA,KAAK;IACZC,KAAK,EAAEA,KAAK;IACZH,OAAO,EAAEA;EACX,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}