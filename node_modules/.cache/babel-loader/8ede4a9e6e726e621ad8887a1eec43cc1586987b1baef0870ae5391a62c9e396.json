{"ast":null,"code":"import bounds from \"./bounds\";\nimport cut from \"./cut\";\nimport dedup from \"./dedup\";\nimport delta from \"./delta\";\nimport extract from \"./extract\";\nimport geometry from \"./geometry\";\nimport hashmap from \"./hash/hashmap\";\nimport prequantize from \"./prequantize\";\n\n// Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\nexport default function (objects, quantization) {\n  var bbox = bounds(objects = geometry(objects)),\n    transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n    topology = dedup(cut(extract(objects))),\n    coordinates = topology.coordinates,\n    indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n  objects = topology.objects; // for garbage collection\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function (arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n  delete topology.coordinates;\n  coordinates = null;\n  function indexGeometry(geometry) {\n    if (geometry && indexGeometryType.hasOwnProperty(geometry.type)) indexGeometryType[geometry.type](geometry);\n  }\n  var indexGeometryType = {\n    GeometryCollection: function (o) {\n      o.geometries.forEach(indexGeometry);\n    },\n    LineString: function (o) {\n      o.arcs = indexArcs(o.arcs);\n    },\n    MultiLineString: function (o) {\n      o.arcs = o.arcs.map(indexArcs);\n    },\n    Polygon: function (o) {\n      o.arcs = o.arcs.map(indexArcs);\n    },\n    MultiPolygon: function (o) {\n      o.arcs = o.arcs.map(indexMultiArcs);\n    }\n  };\n  function indexArcs(arc) {\n    var indexes = [];\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n    return indexes;\n  }\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n  if (transform) {\n    topology.transform = transform;\n    topology.arcs = delta(topology.arcs);\n  }\n  return topology;\n}\nfunction hashArc(arc) {\n  var i = arc[0],\n    j = arc[1],\n    t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0],\n    ja = arcA[1],\n    ib = arcB[0],\n    jb = arcB[1],\n    t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}","map":{"version":3,"names":["bounds","cut","dedup","delta","extract","geometry","hashmap","prequantize","objects","quantization","bbox","transform","topology","coordinates","indexByArc","arcs","length","hashArc","equalArc","map","arc","i","set","slice","indexGeometry","indexGeometryType","hasOwnProperty","type","GeometryCollection","o","geometries","forEach","LineString","indexArcs","MultiLineString","Polygon","MultiPolygon","indexMultiArcs","indexes","index","get","push","next","key","j","t","arcA","arcB","ia","ja","ib","jb"],"sources":["C:/Users/johns/OneDrive/桌面/practice/map/node_modules/topojson-server/src/topology.js"],"sourcesContent":["import bounds from \"./bounds\";\nimport cut from \"./cut\";\nimport dedup from \"./dedup\";\nimport delta from \"./delta\";\nimport extract from \"./extract\";\nimport geometry from \"./geometry\";\nimport hashmap from \"./hash/hashmap\";\nimport prequantize from \"./prequantize\";\n\n// Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\nexport default function(objects, quantization) {\n  var bbox = bounds(objects = geometry(objects)),\n      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n      topology = dedup(cut(extract(objects))),\n      coordinates = topology.coordinates,\n      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n\n  objects = topology.objects; // for garbage collection\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function(arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n\n  delete topology.coordinates;\n  coordinates = null;\n\n  function indexGeometry(geometry) {\n    if (geometry && indexGeometryType.hasOwnProperty(geometry.type)) indexGeometryType[geometry.type](geometry);\n  }\n\n  var indexGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },\n    LineString: function(o) { o.arcs = indexArcs(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }\n  };\n\n  function indexArcs(arc) {\n    var indexes = [];\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n    return indexes;\n  }\n\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n\n  if (transform) {\n    topology.transform = transform;\n    topology.arcs = delta(topology.arcs);\n  }\n\n  return topology;\n}\n\nfunction hashArc(arc) {\n  var i = arc[0], j = arc[1], t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\n\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0], ja = arcA[1],\n      ib = arcB[0], jb = arcB[1], t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}