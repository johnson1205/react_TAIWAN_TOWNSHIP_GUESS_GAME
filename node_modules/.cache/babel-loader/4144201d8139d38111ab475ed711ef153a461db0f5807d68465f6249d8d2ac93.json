{"ast":null,"code":"import hashmap from \"./hash/hashmap\";\nimport equalPoint from \"./hash/point-equal\";\nimport hashPoint from \"./hash/point-hash\";\n\n// Given a cut topology, combines duplicate arcs.\nexport default function (topology) {\n  var coordinates = topology.coordinates,\n    lines = topology.lines,\n    line,\n    rings = topology.rings,\n    ring,\n    arcCount = lines.length + rings.length,\n    i,\n    n;\n  delete topology.lines;\n  delete topology.rings;\n\n  // Count the number of (non-unique) arcs to initialize the hashmap safely.\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n    while (line = line.next) ++arcCount;\n  }\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n    while (ring = ring.next) ++arcCount;\n  }\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n    arcs = topology.arcs = [];\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n    if (ring.next) {\n      // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n  function dedupLine(arc) {\n    var startPoint, endPoint, startArcs, startArc, endArcs, endArc, i, n;\n\n    // Does this arc match an existing arc in order?\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    }\n\n    // Does this arc match an existing arc in reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n    if (startArcs) startArcs.push(arc);else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n  function dedupRing(arc) {\n    var endPoint, endArcs, endArc, i, n;\n\n    // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    // Otherwise, does this arc match an existing ring in order, or reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n    if (endArcs) endArcs.push(arc);else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0],\n      ib = arcB[0],\n      ja = arcA[1],\n      jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    return true;\n  }\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0],\n      ib = arcB[0],\n      ja = arcA[1],\n      jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    return true;\n  }\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0],\n      ib = arcB[0],\n      ja = arcA[1],\n      jb = arcB[1],\n      n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n      kb = findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n    return true;\n  }\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0],\n      ib = arcB[0],\n      ja = arcA[1],\n      jb = arcB[1],\n      n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n      kb = n - findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n      end = arc[1],\n      mid = start,\n      minimum = mid,\n      minimumPoint = coordinates[mid];\n    while (++mid < end) {\n      var point = coordinates[mid];\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n    return minimum - start;\n  }\n  return topology;\n}","map":{"version":3,"names":["hashmap","equalPoint","hashPoint","topology","coordinates","lines","line","rings","ring","arcCount","length","i","n","next","arcsByEnd","arcs","dedupLine","dedupRing","arc","startPoint","endPoint","startArcs","startArc","endArcs","endArc","get","equalLine","reverseEqualLine","push","set","equalRing","reverseEqualRing","findMinimumOffset","arcA","arcB","ia","ib","ja","jb","ka","kb","start","end","mid","minimum","minimumPoint","point"],"sources":["C:/Users/johns/OneDrive/桌面/practice/map/node_modules/topojson-server/src/dedup.js"],"sourcesContent":["import hashmap from \"./hash/hashmap\";\nimport equalPoint from \"./hash/point-equal\";\nimport hashPoint from \"./hash/point-hash\";\n\n// Given a cut topology, combines duplicate arcs.\nexport default function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines, line,\n      rings = topology.rings, ring,\n      arcCount = lines.length + rings.length,\n      i, n;\n\n  delete topology.lines;\n  delete topology.rings;\n\n  // Count the number of (non-unique) arcs to initialize the hashmap safely.\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i]; while (line = line.next) ++arcCount;\n  }\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i]; while (ring = ring.next) ++arcCount;\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n    if (ring.next) { // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint,\n        endPoint,\n        startArcs, startArc,\n        endArcs, endArc,\n        i, n;\n\n    // Does this arc match an existing arc in order?\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    }\n\n    // Does this arc match an existing arc in reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint,\n        endArcs,\n        endArc,\n        i, n;\n\n    // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    // Otherwise, does this arc match an existing ring in order, or reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n    while (++mid < end) {\n      var point = coordinates[mid];\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n    return minimum - start;\n  }\n\n  return topology;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}